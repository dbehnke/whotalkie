<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WhoTalkie PTT Dashboard</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        .status {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            gap: 20px;
        }
        .status-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            flex: 1;
        }
        .status-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }
        .status-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        .ptt-controls {
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            background: #fafafa;
        }
        .channels-section, .users-section {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .channels-panel, .users-panel {
            flex: 1;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: white;
        }
        .panel-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .channel-list, .user-list {
            max-height: 200px;
            overflow-y: auto;
        }
        .channel-item, .user-item {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .channel-item:hover {
            background: #e3f2fd;
        }
        .channel-item.active {
            background: #2196F3;
            color: white;
        }
        .user-item.active {
            background: #4CAF50;
            color: white;
        }
        .user-item.talking {
            background: #FF9800;
            color: white;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        .ptt-button {
            width: 100%;
            height: 80px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            margin: 10px 0;
        }
        .ptt-button:hover {
            background: #45a049;
        }
        .ptt-button:active, .ptt-button.active {
            background: #FF5722;
            transform: scale(0.98);
        }
        .ptt-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .connection-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #f44336;
        }
        .status-indicator.connected {
            background: #4CAF50;
        }
        #messages {
            height: 150px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        .channel-input {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .join-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        .join-button:hover {
            background: #1976D2;
        }
        .leave-button {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 5px;
        }
        .leave-button:hover {
            background: #d32f2f;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>WhoTalkie PTT Dashboard</h1>
            <p>Push-to-Talk Communication Server</p>
        </div>
        
        <div class="status">
            <div class="status-item">
                <div class="status-value" id="server-status">Online</div>
                <div class="status-label">Server Status</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="active-channels">0</div>
                <div class="status-label">Active Channels</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="connected-users">0</div>
                <div class="status-label">Connected Users</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="total-clients">0</div>
                <div class="status-label">Total Clients</div>
            </div>
        </div>

        <div class="ptt-controls">
            <div class="connection-info">
                <div class="status-indicator" id="connection-status"></div>
                <span id="connection-text">Disconnected</span>
                <span id="user-info"></span>
            </div>
            
            <div>
                <input type="text" id="channel-input" class="channel-input" placeholder="Enter channel name (e.g., 'general', 'team1')" />
                <button onclick="joinChannel()" class="join-button">Join Channel</button>
                <button onclick="leaveChannel()" class="leave-button">Leave Channel</button>
            </div>
            
            <button id="ptt-button" class="ptt-button" disabled 
                    onmousedown="startPTT()" onmouseup="endPTT()" 
                    ontouchstart="startPTT()" ontouchend="endPTT()">
                HOLD TO TALK
            </button>
            <div style="text-align: center; font-size: 12px; color: #666;">
                Hold the button down to transmit. Release to stop.
            </div>
        </div>

        <div class="channels-section">
            <div class="channels-panel">
                <div class="panel-title">Active Channels</div>
                <div id="channels-list" class="channel-list">
                    <div style="color: #999; text-align: center; padding: 20px;">No active channels</div>
                </div>
            </div>
            <div class="users-panel">
                <div class="panel-title">Connected Users</div>
                <div id="users-list" class="user-list">
                    <div style="color: #999; text-align: center; padding: 20px;">No connected users</div>
                </div>
            </div>
        </div>

        <div class="ptt-controls">
            <h3>Activity Log</h3>
            <div id="messages"></div>
        </div>
    </div>

    <script>
        let ws = null;
        let currentUser = null;
        let currentChannel = '';
        let isPTTActive = false;
        
        // Audio system variables
        let audioContext = null;
        let mediaStream = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let audioPlaybackQueue = [];
        let isPlayingAudio = false;
        let nextPlayTime = 0;
        let activeAudioSources = new Map(); // Track audio sources by user ID
        let audioMixer = null;
        let audioMixerGain = null;
        let userAudioBuffers = new Map(); // Store audio buffers by user ID
        let microphonePermission = false;
        
        const messagesDiv = document.getElementById('messages');
        const connectionStatus = document.getElementById('connection-status');
        const connectionText = document.getElementById('connection-text');
        const userInfo = document.getElementById('user-info');
        const pttButton = document.getElementById('ptt-button');

        // Audio System Functions
        async function initializeAudio() {
            try {
                addMessage('Requesting microphone access...');
                
                mediaStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,  // Disable for lower latency
                        noiseSuppression: false,  // Disable for lower latency  
                        autoGainControl: false,   // Disable for lower latency
                        sampleRate: 44100,
                        channelCount: 1           // Mono for efficiency
                    } 
                });
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                microphonePermission = true;
                
                addMessage('‚úÖ Microphone access granted');
                updatePTTButtonState();
                
            } catch (error) {
                addMessage('‚ùå Microphone access denied: ' + error.message);
                microphonePermission = false;
                updatePTTButtonState();
            }
        }

        function updatePTTButtonState() {
            if (microphonePermission && currentChannel && ws && ws.readyState === WebSocket.OPEN) {
                pttButton.disabled = false;
                pttButton.textContent = 'HOLD TO TALK (with audio)';
            } else if (currentChannel && ws && ws.readyState === WebSocket.OPEN) {
                pttButton.disabled = false;
                pttButton.textContent = 'HOLD TO TALK (events only)';
            } else {
                pttButton.disabled = true;
                pttButton.textContent = 'JOIN CHANNEL TO TALK';
            }
        }

        function startAudioCapture() {
            if (!microphonePermission || !mediaStream) {
                addMessage('‚ö†Ô∏è No microphone access - sending PTT event only');
                return;
            }

            try {
                // Use Web Audio API for raw PCM capture instead of MediaRecorder
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Resume audio context if suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Create audio processing chain
                const source = audioContext.createMediaStreamSource(mediaStream);
                const processor = audioContext.createScriptProcessor(2048, 1, 1); // Smaller buffer for lower latency
                
                addMessage('üéµ Using PCM audio capture via Web Audio API');
                addMessage('üìä Sample rate: ' + audioContext.sampleRate + 'Hz');
                
                processor.onaudioprocess = function(event) {
                    const inputBuffer = event.inputBuffer;
                    const inputData = inputBuffer.getChannelData(0); // Get mono channel
                    
                    // Convert Float32Array to Int16Array (PCM 16-bit)
                    const pcmData = new Int16Array(inputData.length);
                    for (let i = 0; i < inputData.length; i++) {
                        // Clamp to [-1, 1] and convert to 16-bit PCM
                        const sample = Math.max(-1, Math.min(1, inputData[i]));
                        pcmData[i] = sample * 32767;
                    }
                    
                    // Send PCM data immediately for real-time streaming
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        sendPCMAudioChunk(pcmData);
                    }
                };
                
                // Connect the audio processing chain
                source.connect(processor);
                processor.connect(audioContext.destination); // Connect to destination to prevent garbage collection
                
                // Store references for cleanup
                window.audioSource = source;
                window.audioProcessor = processor;
                
                addMessage('üé§ PCM audio capture started');
                
            } catch (error) {
                addMessage('‚ùå Audio capture failed: ' + error.message);
            }
        }

        function stopAudioCapture() {
            // Clean up Web Audio API nodes
            if (window.audioProcessor) {
                window.audioProcessor.disconnect();
                window.audioProcessor = null;
                addMessage('üé§ PCM audio capture stopped');
            }
            
            if (window.audioSource) {
                window.audioSource.disconnect();
                window.audioSource = null;
            }
            
            // Reset playback timing for next session
            nextPlayTime = 0;
        }

        function sendPCMAudioChunk(pcmData) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                // Check size limit (8KB max for better real-time performance)
                const byteLength = pcmData.length * 2; // Int16Array is 2 bytes per sample
                if (byteLength > 8000) {
                    addMessage('‚ö†Ô∏è PCM chunk too large: ' + byteLength + ' bytes, skipping');
                    return;
                }

                // Send audio metadata first
                const audioEvent = {
                    type: 'audio_data',
                    timestamp: new Date().toISOString(),
                    data: {
                        chunk_size: byteLength,
                        format: 'pcm',
                        sample_rate: audioContext.sampleRate,
                        channels: 1,
                        bit_depth: 16
                    }
                };
                
                ws.send(JSON.stringify(audioEvent));
                
                // Then send the binary PCM data
                ws.send(pcmData.buffer);
                
                // Reduced logging for real-time performance
                if (Math.random() < 0.05) { // Only log 5% of chunks
                    addMessage('üì§ Sent PCM chunk: ' + byteLength + ' bytes');
                }
            } else {
                addMessage('‚ùå WebSocket not ready for audio transmission');
            }
        }

        function sendAudioChunk(audioBlob) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                // Check size limit (32KB max to be safe)
                if (audioBlob.size > 30000) {
                    addMessage('‚ö†Ô∏è Audio chunk too large (' + audioBlob.size + ' bytes), skipping');
                    return;
                }
                
                addMessage('üì° Sending audio chunk: ' + audioBlob.size + ' bytes');
                
                // Convert blob to array buffer and send as binary
                audioBlob.arrayBuffer().then(buffer => {
                    // Create a header with metadata
                    // Get the actual MIME type from the MediaRecorder
                    let actualFormat = 'webm/opus';
                    if (mediaRecorder && mediaRecorder.mimeType) {
                        actualFormat = mediaRecorder.mimeType;
                    }
                    
                    const metadata = {
                        type: 'audio_data',
                        user_id: currentUser ? currentUser.id : '',
                        channel_id: currentChannel,
                        timestamp: new Date().toISOString(),
                        audio_format: actualFormat,
                        chunk_size: buffer.byteLength
                    };
                    
                    addMessage('üì§ Sending metadata + ' + buffer.byteLength + ' bytes audio data');
                    
                    // Send metadata first, then audio data
                    ws.send(JSON.stringify(metadata));
                    ws.send(buffer);
                });
            } else {
                addMessage('‚ùå WebSocket not ready for audio transmission');
            }
        }

        // Store current audio metadata for mixing
        let currentAudioMetadata = null;
        
        function initializeAudioMixer() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            if (!audioMixer) {
                // Create a gain node to control overall mixed volume
                audioMixerGain = audioContext.createGain();
                audioMixerGain.gain.value = 0.7; // Reduce volume to prevent clipping when mixing
                audioMixerGain.connect(audioContext.destination);
                
                addMessage('üéöÔ∏è Audio mixer initialized for multi-user support');
            }
        }
        
        async function tryPlayPCMAudioWithMixing(audioData, userID) {
            try {
                // Initialize audio context and mixer if needed
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Resume audio context if suspended
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                // Initialize mixer if needed
                if (!audioMixerGain) {
                    initializeAudioMixer();
                }
                
                // Convert ArrayBuffer to Int16Array (PCM 16-bit)
                const pcmData = new Int16Array(audioData);
                
                if (pcmData.length === 0) {
                    return false;
                }
                
                // Create audio buffer for this user
                const sampleRate = audioContext.sampleRate;
                const audioBuffer = audioContext.createBuffer(1, pcmData.length, sampleRate);
                const channelData = audioBuffer.getChannelData(0);
                
                // Convert Int16 PCM to Float32 for Web Audio API
                for (let i = 0; i < pcmData.length; i++) {
                    channelData[i] = pcmData[i] / 32767.0; // Normalize to [-1, 1]
                }
                
                // Create individual gain node for this user (for volume control/mixing)
                const userGain = audioContext.createGain();
                userGain.gain.value = 1.0 / Math.max(1, activeAudioSources.size + 1); // Auto-adjust volume based on active speakers
                
                // Create and play audio source
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                
                // Connect: source -> userGain -> mixerGain -> destination
                source.connect(userGain);
                userGain.connect(audioMixerGain);
                
                // Track this user's audio source
                const sourceInfo = {
                    source: source,
                    gain: userGain,
                    startTime: audioContext.currentTime
                };
                
                activeAudioSources.set(userID, sourceInfo);
                
                // Schedule playback
                const startTime = Math.max(audioContext.currentTime, nextPlayTime);
                source.start(startTime);
                
                // Clean up when audio finishes
                source.onended = () => {
                    activeAudioSources.delete(userID);
                    userGain.disconnect();
                };
                
                // Update next play time for smooth continuation
                nextPlayTime = startTime + audioBuffer.duration;
                if (nextPlayTime < audioContext.currentTime) {
                    nextPlayTime = audioContext.currentTime;
                }
                
                return true;
                
            } catch (error) {
                addMessage('‚ö†Ô∏è Mixed PCM playback failed: ' + error.message);
                return false;
            }
        }
        
        async function playReceivedAudio(audioData, userID = 'unknown') {
            try {
                // Reduced logging for better performance
                if (Math.random() < 0.02) { // Only log 2% of chunks
                    addMessage('üîä Audio chunk from ' + userID + ' (' + audioData.byteLength + ' bytes)');
                }
                
                // Check if this looks like PCM data (should be divisible by 2 for 16-bit samples)
                if (audioData.byteLength > 0 && audioData.byteLength % 2 === 0) {
                    // Try to play as PCM with mixing support
                    if (await tryPlayPCMAudioWithMixing(audioData, userID)) {
                        if (Math.random() < 0.01) { // Only log 1% success messages
                            addMessage('üéµ Mixed PCM audio from ' + userID);
                        }
                        return;
                    }
                }
                
                // Fallback to non-mixed playback
                if (await tryPlayPCMAudio(audioData)) {
                    return;
                }
                
                // Convert ArrayBuffer to Uint8Array for container format handling
                let bytes;
                if (audioData instanceof ArrayBuffer) {
                    bytes = new Uint8Array(audioData);
                } else if (audioData instanceof Blob) {
                    const arrayBuffer = await audioData.arrayBuffer();
                    bytes = new Uint8Array(arrayBuffer);
                } else {
                    bytes = audioData;
                }
                
                // Try to extract and play Opus audio from WebM container
                if (await tryPlayOpusAudio(bytes)) {
                    addMessage('üéµ Playing Opus audio successfully');
                } else {
                    // Fallback to creating playable WebM blob
                    await tryPlayWebMBlob(bytes);
                }
                
            } catch (error) {
                addMessage('‚ùå Error handling audio: ' + error.message);
                playAudioConfirmationBeep(); // Fallback beep
            }
        }

        async function tryPlayPCMAudio(audioData) {
            try {
                // Initialize audio context if needed
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Resume audio context if suspended
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                // Convert ArrayBuffer to Int16Array (PCM 16-bit)
                const pcmData = new Int16Array(audioData);
                
                if (pcmData.length === 0) {
                    return false;
                }
                
                // Add to playback queue for smooth buffered playback
                audioPlaybackQueue.push(pcmData);
                
                // Start playback processor if not already running
                if (!isPlayingAudio) {
                    processAudioPlaybackQueue();
                }
                
                return true;
                
            } catch (error) {
                addMessage('‚ö†Ô∏è PCM playback failed: ' + error.message);
                return false;
            }
        }

        async function processAudioPlaybackQueue() {
            if (isPlayingAudio) return;
            isPlayingAudio = true;
            
            // Initialize playback timing
            if (nextPlayTime === 0) {
                nextPlayTime = audioContext.currentTime;
            }
            
            while (audioPlaybackQueue.length > 0) {
                const pcmData = audioPlaybackQueue.shift();
                
                try {
                    // Create audio buffer for playback
                    const sampleRate = audioContext.sampleRate;
                    const audioBuffer = audioContext.createBuffer(1, pcmData.length, sampleRate);
                    const channelData = audioBuffer.getChannelData(0);
                    
                    // Convert Int16 PCM to Float32 for Web Audio API
                    for (let i = 0; i < pcmData.length; i++) {
                        channelData[i] = pcmData[i] / 32767.0; // Normalize to [-1, 1]
                    }
                    
                    // Create and schedule audio source for seamless playback
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(audioContext.destination);
                    
                    // Schedule playback at the exact right time for smooth audio
                    source.start(nextPlayTime);
                    
                    // Calculate next play time for seamless continuation
                    const chunkDuration = audioBuffer.duration;
                    nextPlayTime += chunkDuration;
                    
                    // If we've fallen behind real-time, catch up
                    if (nextPlayTime < audioContext.currentTime) {
                        nextPlayTime = audioContext.currentTime;
                    }
                    
                } catch (error) {
                    addMessage('‚ö†Ô∏è Audio playback scheduling failed: ' + error.message);
                }
                
                // Small delay to prevent overwhelming the audio system
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            isPlayingAudio = false;
        }

        async function tryPlayOpusAudio(bytes) {
            try {
                // Simple WebM container parsing to find Opus frames
                const dataView = new DataView(bytes.buffer || bytes);
                
                // Look for Opus audio blocks in WebM (simplified parser)
                let opusData = null;
                let offset = 0;
                
                // Scan for Opus frames (this is a simplified approach)
                while (offset < bytes.length - 4) {
                    // Look for WebM SimpleBlock or Block elements that contain Opus data
                    if (bytes[offset] === 0xa3) { // SimpleBlock
                        // Skip past WebM container headers and extract audio payload
                        let blockSize = 0;
                        let headerOffset = offset + 1;
                        
                        // Parse EBML variable-length integer for block size
                        let firstByte = bytes[headerOffset];
                        if ((firstByte & 0x80) !== 0) {
                            blockSize = firstByte & 0x7f;
                            headerOffset += 1;
                        } else if ((firstByte & 0x40) !== 0) {
                            blockSize = ((firstByte & 0x3f) << 8) | bytes[headerOffset + 1];
                            headerOffset += 2;
                        }
                        
                        if (blockSize > 0 && blockSize < bytes.length - headerOffset) {
                            // Extract potential Opus payload
                            const payload = bytes.slice(headerOffset + 3, headerOffset + blockSize);
                            if (payload.length > 10) {
                                opusData = payload;
                                break;
                            }
                        }
                    }
                    offset++;
                }
                
                if (opusData) {
                    // Try to decode and play Opus data using Web Audio API
                    if (!audioContext) {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    // Create a simple Opus frame wrapper that browsers can decode
                    const opusBlob = new Blob([opusData], { type: 'audio/opus' });
                    const arrayBuffer = await opusBlob.arrayBuffer();
                    
                    try {
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        const source = audioContext.createBufferSource();
                        source.buffer = audioBuffer;
                        source.connect(audioContext.destination);
                        source.start(0);
                        
                        addMessage('üéµ Decoded and playing Opus audio!');
                        return true;
                    } catch (decodeError) {
                        addMessage('‚ö†Ô∏è Opus decode failed, trying alternative: ' + decodeError.message);
                        return false;
                    }
                }
                
                return false;
                
            } catch (error) {
                addMessage('‚ö†Ô∏è Opus extraction failed: ' + error.message);
                return false;
            }
        }

        async function tryPlayWebMBlob(bytes) {
            try {
                // Create a complete WebM blob and try to play it
                const blob = new Blob([bytes], { type: 'audio/webm;codecs=opus' });
                const url = URL.createObjectURL(blob);
                
                const audio = new Audio();
                audio.src = url;
                
                return new Promise((resolve, reject) => {
                    audio.oncanplay = () => {
                        addMessage('üéµ Playing WebM audio');
                        audio.play().then(() => {
                            resolve(true);
                        }).catch(reject);
                    };
                    
                    audio.onerror = () => {
                        URL.revokeObjectURL(url);
                        addMessage('‚ö†Ô∏è WebM playback failed, using confirmation beep');
                        playAudioConfirmationBeep();
                        resolve(false);
                    };
                    
                    audio.onended = () => {
                        URL.revokeObjectURL(url);
                    };
                    
                    // Timeout after 1 second
                    setTimeout(() => {
                        if (audio.readyState === 0) {
                            URL.revokeObjectURL(url);
                            addMessage('‚ö†Ô∏è Audio load timeout, using confirmation beep');
                            playAudioConfirmationBeep();
                            resolve(false);
                        }
                    }, 1000);
                });
                
            } catch (error) {
                addMessage('‚ö†Ô∏è WebM blob creation failed: ' + error.message);
                playAudioConfirmationBeep();
                return false;
            }
        }
        
        // Confirmation beep to indicate audio is being relayed
        function playAudioConfirmationBeep() {
            try {
                // Initialize audio context if needed
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Resume audio context if suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Create a very brief, subtle beep
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Higher frequency for less intrusive sound
                oscillator.frequency.setValueAtTime(1200, audioContext.currentTime);
                oscillator.type = 'sine';
                
                // Very quiet and brief
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.005);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);
                
                // Very short duration
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.05);
                
            } catch (error) {
                // Silent fail for beep generation
            }
        }
        
        // Keep the notification sound as fallback
        function playNotificationSound() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
                
                addMessage('üîî Audio received (notification tone)');
                
            } catch (error) {
                addMessage('‚ùå Could not play notification: ' + error.message);
            }
        }

        function connect() {
            if (ws) return;
            
            ws = new WebSocket('ws://localhost:8080/ws');
            
            ws.onopen = function() {
                connectionStatus.classList.add('connected');
                connectionText.textContent = 'Connected';
                addMessage('Connected to server');
                updateStats();
            };
            
            ws.onmessage = function(event) {
                if (event.data instanceof ArrayBuffer) {
                    // Handle binary audio data with user ID from previous metadata
                    const userID = currentAudioMetadata ? currentAudioMetadata.user_id : 'unknown';
                    
                    // Only log occasionally for performance
                    if (Math.random() < 0.02) {
                        addMessage('üì° Received ArrayBuffer audio from ' + userID + ': ' + event.data.byteLength + ' bytes');
                    }
                    
                    playReceivedAudio(event.data, userID);
                    currentAudioMetadata = null; // Clear after use
                    
                } else if (event.data instanceof Blob) {
                    // Handle binary audio data as Blob with user ID
                    const userID = currentAudioMetadata ? currentAudioMetadata.user_id : 'unknown';
                    
                    if (Math.random() < 0.02) {
                        addMessage('üì° Received Blob audio from ' + userID + ': ' + event.data.size + ' bytes');
                    }
                    
                    event.data.arrayBuffer().then(buffer => {
                        playReceivedAudio(buffer, userID);
                    });
                    currentAudioMetadata = null; // Clear after use
                    
                } else if (typeof event.data === 'string') {
                    try {
                        const data = JSON.parse(event.data);
                        
                        // Check if this is audio metadata
                        if (data.type === 'audio_data') {
                            currentAudioMetadata = data;
                            // Don't handle as regular event, just store for next binary message
                            return;
                        }
                        
                        handleServerEvent(data);
                    } catch (e) {
                        addMessage('Received text: ' + event.data);
                    }
                } else {
                    addMessage('Received unknown data type: ' + typeof event.data);
                }
            };
            
            ws.onclose = function() {
                connectionStatus.classList.remove('connected');
                connectionText.textContent = 'Disconnected';
                userInfo.textContent = '';
                addMessage('Disconnected from server');
                pttButton.disabled = true;
                ws = null;
                
                // Try to reconnect after 3 seconds
                setTimeout(connect, 3000);
            };
            
            ws.onerror = function(error) {
                addMessage('Connection error: ' + error);
            };
        }

        function handleServerEvent(event) {
            addMessage(`Event: ${event.type} from ${event.user_id} ${event.data ? '- ' + JSON.stringify(event.data) : ''}`);
            
            switch (event.type) {
                case 'user_join':
                    if (event.user_id && event.data && event.data.username) {
                        if (!currentUser && ws && ws.readyState === WebSocket.OPEN) {
                            // This might be us
                            const parts = event.user_id.split('-');
                            if (parts.length > 0) {
                                currentUser = {
                                    id: event.user_id,
                                    username: event.data.username
                                };
                                userInfo.textContent = ` - ${event.data.username}`;
                                pttButton.disabled = false;
                            }
                        }
                    }
                    updateStats();
                    updateUsersList();
                    break;
                    
                case 'user_leave':
                    updateStats();
                    updateUsersList();
                    break;
                    
                case 'channel_join':
                    if (event.user_id === (currentUser ? currentUser.id : '')) {
                        currentChannel = event.channel_id;
                        document.getElementById('channel-input').value = currentChannel;
                        updatePTTButtonState();
                    }
                    updateStats();
                    updateChannelsList();
                    updateUsersList();
                    break;
                    
                case 'channel_leave':
                    if (event.user_id === (currentUser ? currentUser.id : '')) {
                        currentChannel = '';
                        document.getElementById('channel-input').value = '';
                        updatePTTButtonState();
                    }
                    updateStats();
                    updateChannelsList();
                    updateUsersList();
                    break;
                    
                case 'ptt_start':
                    addMessage(`üéôÔ∏è ${event.data.username} started talking in ${event.channel_id}`);
                    highlightTalkingUser(event.user_id, true);
                    break;
                    
                case 'ptt_end':
                    addMessage(`üîá ${event.data.username} stopped talking in ${event.channel_id}`);
                    highlightTalkingUser(event.user_id, false);
                    break;
                    
                case 'heartbeat':
                    // Silent heartbeat response
                    break;
            }
        }

        function sendEvent(eventType, data = {}) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const event = {
                    type: eventType,
                    channel_id: currentChannel,
                    timestamp: new Date().toISOString(),
                    data: data
                };
                ws.send(JSON.stringify(event));
            }
        }

        function joinChannel() {
            const channelName = document.getElementById('channel-input').value.trim();
            if (!channelName) {
                alert('Please enter a channel name');
                return;
            }
            
            sendEvent('channel_join', { channel_name: channelName });
        }

        function leaveChannel() {
            if (currentChannel) {
                sendEvent('channel_leave');
            }
        }

        function startPTT() {
            if (!currentChannel || isPTTActive) return;
            
            isPTTActive = true;
            pttButton.classList.add('active');
            
            if (microphonePermission) {
                pttButton.textContent = 'TRANSMITTING AUDIO...';
                startAudioCapture();
            } else {
                pttButton.textContent = 'TRANSMITTING EVENT...';
            }
            
            sendEvent('ptt_start');
        }

        function endPTT() {
            if (!isPTTActive) return;
            
            isPTTActive = false;
            pttButton.classList.remove('active');
            
            if (microphonePermission) {
                stopAudioCapture();
            }
            
            updatePTTButtonState();
            sendEvent('ptt_end');
        }

        function updateStats() {
            fetch('/api/stats')
                .then(response => response.json())
                .then(stats => {
                    document.getElementById('active-channels').textContent = stats.active_channels;
                    document.getElementById('connected-users').textContent = stats.active_users;
                    document.getElementById('total-clients').textContent = stats.connected_clients;
                })
                .catch(err => console.error('Failed to fetch stats:', err));
        }

        function updateChannelsList() {
            fetch('/api/channels')
                .then(response => response.json())
                .then(data => {
                    const channelsList = document.getElementById('channels-list');
                    if (data.channels && data.channels.length > 0) {
                        channelsList.innerHTML = data.channels.map(channel => 
                            `<div class="channel-item ${channel.id === currentChannel ? 'active' : ''}" onclick="selectChannel('${channel.id}')">
                                ${channel.name} (${channel.users.length} users)
                            </div>`
                        ).join('');
                    } else {
                        channelsList.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">No active channels</div>';
                    }
                })
                .catch(err => console.error('Failed to fetch channels:', err));
        }

        function updateUsersList() {
            fetch('/api/users')
                .then(response => response.json())
                .then(data => {
                    const usersList = document.getElementById('users-list');
                    if (data.users && data.users.length > 0) {
                        usersList.innerHTML = data.users.map(user => 
                            `<div class="user-item ${user.is_active ? 'active' : ''}" id="user-${user.id}">
                                ${user.username}${user.channel ? ` (${user.channel})` : ''}
                            </div>`
                        ).join('');
                    } else {
                        usersList.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">No connected users</div>';
                    }
                })
                .catch(err => console.error('Failed to fetch users:', err));
        }

        function selectChannel(channelId) {
            document.getElementById('channel-input').value = channelId;
            joinChannel();
        }

        function highlightTalkingUser(userId, isTalking) {
            const userElement = document.getElementById(`user-${userId}`);
            if (userElement) {
                if (isTalking) {
                    userElement.classList.add('talking');
                } else {
                    userElement.classList.remove('talking');
                }
            }
        }

        function addMessage(message) {
            const div = document.createElement('div');
            div.textContent = new Date().toLocaleTimeString() + ' - ' + message;
            messagesDiv.appendChild(div);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.code === 'Space' && !e.repeat) {
                e.preventDefault();
                startPTT();
            }
        });

        document.addEventListener('keyup', function(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                endPTT();
            }
        });

        // Prevent space from scrolling page when used for PTT
        window.addEventListener('keydown', function(e) {
            if(e.keyCode === 32 && e.target === document.body) {
                e.preventDefault();
            }
        });

        // Auto-connect and periodic updates
        window.onload = function() {
            connect();
            initializeAudio();
            setInterval(updateStats, 2000);
            setInterval(updateChannelsList, 3000);
            setInterval(updateUsersList, 3000);
        };
    </script>
</body>
</html>