<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WhoTalkie PTT Dashboard</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        .status {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            gap: 20px;
        }
        .status-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            flex: 1;
        }
        .status-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }
        .status-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        .ptt-controls {
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            background: #fafafa;
        }
        .channels-section, .users-section {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .channels-panel, .users-panel {
            flex: 1;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: white;
        }
        .panel-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .channel-list, .user-list {
            max-height: 200px;
            overflow-y: auto;
        }
        .channel-item, .user-item {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .channel-item:hover {
            background: #e3f2fd;
        }
        .channel-item.active {
            background: #2196F3;
            color: white;
        }
        .user-item.active {
            background: #4CAF50;
            color: white;
        }
        .user-item.talking {
            background: #FF9800;
            color: white;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        .ptt-button {
            width: 100%;
            height: 80px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            margin: 10px 0;
        }
        .ptt-button:hover {
            background: #45a049;
        }
        .ptt-button:active, .ptt-button.active {
            background: #FF5722;
            transform: scale(0.98);
        }
        .ptt-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .connection-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #f44336;
        }
        .status-indicator.connected {
            background: #4CAF50;
        }
        #messages {
            height: 150px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        .channel-input {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .join-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        .join-button:hover {
            background: #1976D2;
        }
        .leave-button {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 5px;
        }
        .leave-button:hover {
            background: #d32f2f;
        }
    </style>
    <!-- Using WebCodecs API for native Opus support - no external libraries needed -->
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>WhoTalkie PTT Dashboard</h1>
            <p>Push-to-Talk Communication Server</p>
        </div>
        
        <div class="status">
            <div class="status-item">
                <div class="status-value" id="server-status">Online</div>
                <div class="status-label">Server Status</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="active-channels">0</div>
                <div class="status-label">Active Channels</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="connected-users">0</div>
                <div class="status-label">Connected Users</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="total-clients">0</div>
                <div class="status-label">Total Clients</div>
            </div>
        </div>

        <div class="ptt-controls">
            <div class="connection-info">
                <div class="status-indicator" id="connection-status"></div>
                <span id="connection-text">Disconnected</span>
                <span id="user-info"></span>
            </div>
            
            <div id="audio-stats" style="display: none; background: #f0f0f0; padding: 10px; border-radius: 4px; margin: 10px 0; font-family: monospace; font-size: 12px;">
                <div style="display: flex; justify-content: space-between; gap: 20px;">
                    <div id="transmission-stats">
                        <strong>üì§ Transmitting:</strong><br>
                        Duration: <span id="tx-duration">0.0s</span><br>
                        Bytes: <span id="tx-bytes">0</span><br>
                        Bitrate: <span id="tx-bitrate">0 kbps</span>
                    </div>
                    <div id="reception-stats">
                        <strong>üì• Receiving:</strong><br>
                        Duration: <span id="rx-duration">0.0s</span><br>
                        Bytes: <span id="rx-bytes">0</span><br>
                        Bitrate: <span id="rx-bitrate">0 kbps</span>
                    </div>
                </div>
            </div>
            
            <div>
                <input type="text" id="channel-input" class="channel-input" placeholder="Enter channel name (e.g., 'general', 'team1')" />
                <button onclick="joinChannel()" class="join-button">Join Channel</button>
                <button onclick="leaveChannel()" class="leave-button">Leave Channel</button>
            </div>
            
            <div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 4px; text-align: center;">
                <label style="font-weight: bold; color: #4CAF50;">üéµ Audio Codec: Opus (WebCodecs API)</label>
                <div id="opus-status" style="font-size: 11px; margin-top: 5px; color: #666;"></div>
            </div>
            
            <button id="ptt-button" class="ptt-button" disabled 
                    onmousedown="startPTT()" onmouseup="endPTT()" 
                    ontouchstart="startPTT()" ontouchend="endPTT()">
                HOLD TO TALK
            </button>
            <div style="text-align: center; font-size: 12px; color: #666;">
                Hold the button down to transmit. Release to stop.
            </div>
        </div>

        <div class="channels-section">
            <div class="channels-panel">
                <div class="panel-title">Active Channels</div>
                <div id="channels-list" class="channel-list">
                    <div style="color: #999; text-align: center; padding: 20px;">No active channels</div>
                </div>
            </div>
            <div class="users-panel">
                <div class="panel-title">Connected Users</div>
                <div id="users-list" class="user-list">
                    <div style="color: #999; text-align: center; padding: 20px;">No connected users</div>
                </div>
            </div>
        </div>

        <div class="ptt-controls">
            <h3>Activity Log</h3>
            <div id="messages"></div>
        </div>
    </div>

    <script>
        let ws = null;
        let currentUser = null;
        let currentChannel = '';
        let isPTTActive = false;
        
        // Audio system variables
        let audioContext = null;
        let mediaStream = null;
        let nextPlayTime = 0;
        let activeAudioSources = new Map(); // Track audio sources by user ID
        let audioMixerGain = null;
        let microphonePermission = false;
        
        // WebCodecs Opus system variables
        let webCodecsEncoder = null;
        let webCodecsDecoder = null;
        const OPUS_SAMPLE_RATE = 48000;
        const OPUS_BITRATE = 32000;
        let webCodecsSupported = false;
        let audioTimestamp = 0; // Track continuous timestamp

        // Audio statistics tracking
        let audioStats = {
            transmitting: false,
            receiving: false,
            transmissionStartTime: 0,
            receptionStartTime: 0,
            transmittedBytes: 0,
            receivedBytes: 0,
            transmissionDuration: 0,
            receptionDuration: 0,
            currentTransmitBitrate: 0,
            currentReceiveBitrate: 0
        };
        let statsUpdateInterval = null;

        // DOM Elements
        const messagesDiv = document.getElementById('messages');
        const connectionStatus = document.getElementById('connection-status');
        const connectionText = document.getElementById('connection-text');
        const userInfo = document.getElementById('user-info');
        const pttButton = document.getElementById('ptt-button');

        // Store metadata for the next binary audio frame
        let currentAudioMetadata = null;

        // Audio statistics functions
        function startTransmissionStats() {
            audioStats.transmitting = true;
            audioStats.transmissionStartTime = performance.now();
            audioStats.transmittedBytes = 0;
            audioStats.currentTransmitBitrate = 0;
            
            document.getElementById('audio-stats').style.display = 'block';
            document.getElementById('transmission-stats').style.opacity = '1';
            
            if (!statsUpdateInterval) {
                statsUpdateInterval = setInterval(updateStatsDisplay, 100); // Update every 100ms
            }
        }

        function stopTransmissionStats() {
            audioStats.transmitting = false;
            document.getElementById('transmission-stats').style.opacity = '0.5';
            
            if (!audioStats.receiving) {
                setTimeout(() => {
                    document.getElementById('audio-stats').style.display = 'none';
                }, 2000); // Hide after 2 seconds if not receiving
            }
            
            if (!audioStats.receiving && statsUpdateInterval) {
                clearInterval(statsUpdateInterval);
                statsUpdateInterval = null;
            }
        }

        function startReceptionStats() {
            audioStats.receiving = true;
            audioStats.receptionStartTime = performance.now();
            audioStats.receivedBytes = 0;
            audioStats.currentReceiveBitrate = 0;
            
            document.getElementById('audio-stats').style.display = 'block';
            document.getElementById('reception-stats').style.opacity = '1';
            
            if (!statsUpdateInterval) {
                statsUpdateInterval = setInterval(updateStatsDisplay, 100);
            }
        }

        function stopReceptionStats() {
            audioStats.receiving = false;
            document.getElementById('reception-stats').style.opacity = '0.5';
            
            if (!audioStats.transmitting) {
                setTimeout(() => {
                    document.getElementById('audio-stats').style.display = 'none';
                }, 2000);
            }
            
            if (!audioStats.transmitting && statsUpdateInterval) {
                clearInterval(statsUpdateInterval);
                statsUpdateInterval = null;
            }
        }

        function updateStatsDisplay() {
            const now = performance.now();
            
            if (audioStats.transmitting) {
                audioStats.transmissionDuration = (now - audioStats.transmissionStartTime) / 1000;
                audioStats.currentTransmitBitrate = audioStats.transmissionDuration > 0 ? 
                    (audioStats.transmittedBytes * 8 / audioStats.transmissionDuration / 1000) : 0;
                
                document.getElementById('tx-duration').textContent = audioStats.transmissionDuration.toFixed(1) + 's';
                document.getElementById('tx-bytes').textContent = formatBytes(audioStats.transmittedBytes);
                document.getElementById('tx-bitrate').textContent = audioStats.currentTransmitBitrate.toFixed(1) + ' kbps';
            }
            
            if (audioStats.receiving) {
                audioStats.receptionDuration = (now - audioStats.receptionStartTime) / 1000;
                audioStats.currentReceiveBitrate = audioStats.receptionDuration > 0 ? 
                    (audioStats.receivedBytes * 8 / audioStats.receptionDuration / 1000) : 0;
                
                document.getElementById('rx-duration').textContent = audioStats.receptionDuration.toFixed(1) + 's';
                document.getElementById('rx-bytes').textContent = formatBytes(audioStats.receivedBytes);
                document.getElementById('rx-bitrate').textContent = audioStats.currentReceiveBitrate.toFixed(1) + ' kbps';
            }
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function updateOpusStatus() {
            const statusDiv = document.getElementById('opus-status');
            
            if (webCodecsSupported) {
                statusDiv.textContent = '‚úÖ WebCodecs Opus encoding/decoding ready';
                statusDiv.style.color = '#4CAF50';
            } else {
                statusDiv.textContent = '‚ùå WebCodecs API not supported in this browser';
                statusDiv.style.color = '#f44336';
            }
        }

        // --- Core Functions ---

        async function initializeAudio() {
            try {
                addMessage('Requesting microphone access...');
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true, // Let browser handle this for simplicity
                        sampleRate: 48000,     // Request 48kHz if possible
                        channelCount: 1
                    }
                });
                microphonePermission = true;
                addMessage('‚úÖ Microphone access granted');
                await initializeWebCodecs(); // Initialize WebCodecs after getting mic stream
                updatePTTButtonState();
            } catch (error) {
                addMessage('‚ùå Microphone access denied: ' + error.message);
                microphonePermission = false;
                updatePTTButtonState();
            }
        }

        async function initializeWebCodecs() {
            // Check WebCodecs API support
            if (!window.AudioEncoder || !window.AudioDecoder) {
                addMessage('‚ùå WebCodecs API not supported. Opus audio unavailable.');
                webCodecsSupported = false;
                updateOpusStatus();
                return;
            }

            try {
                // Check Opus codec support
                const encoderSupport = await AudioEncoder.isConfigSupported({
                    codec: 'opus',
                    sampleRate: OPUS_SAMPLE_RATE,
                    numberOfChannels: 1,
                    bitrate: OPUS_BITRATE
                });
                
                const decoderSupport = await AudioDecoder.isConfigSupported({
                    codec: 'opus',
                    sampleRate: OPUS_SAMPLE_RATE,
                    numberOfChannels: 1
                });

                if (!encoderSupport.supported || !decoderSupport.supported) {
                    addMessage('‚ùå Opus codec not supported by WebCodecs.');
                    webCodecsSupported = false;
                    updateOpusStatus();
                    return;
                }

                addMessage('Initializing WebCodecs Opus encoder/decoder...');
                
                // Initialize encoder
                webCodecsEncoder = new AudioEncoder({
                    output: (encodedChunk) => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            // Send immediately for low latency
                            sendOpusAudioChunk(encodedChunk);
                        }
                    },
                    error: (err) => {
                        addMessage('‚ùå Encoder error: ' + err.message);
                    }
                });
                
                webCodecsEncoder.configure({
                    codec: 'opus',
                    sampleRate: OPUS_SAMPLE_RATE,
                    numberOfChannels: 1,
                    bitrate: OPUS_BITRATE
                });
                
                // Initialize decoder
                webCodecsDecoder = new AudioDecoder({
                    output: (audioData) => {
                        playDecodedAudio(audioData);
                    },
                    error: (err) => {
                        addMessage('‚ùå Decoder error: ' + err.message);
                    }
                });
                
                webCodecsDecoder.configure({
                    codec: 'opus',
                    sampleRate: OPUS_SAMPLE_RATE,
                    numberOfChannels: 1
                });
                
                webCodecsSupported = true;
                addMessage('‚úÖ WebCodecs Opus encoder/decoder initialized successfully.');
                updateOpusStatus(); // Update status display
                
            } catch (err) {
                addMessage('‚ùå Failed to initialize WebCodecs: ' + err.message);
                webCodecsSupported = false;
                updateOpusStatus(); // Update status display
            }
        }

        function resample(inputData, inputSampleRate, outputSampleRate) {
            if (inputSampleRate === outputSampleRate) {
                return inputData;
            }
            const ratio = inputSampleRate / outputSampleRate;
            const outputLength = Math.floor(inputData.length / ratio);
            const outputData = new Float32Array(outputLength);
            for (let i = 0; i < outputLength; i++) {
                const inputIndex = i * ratio;
                const index1 = Math.floor(inputIndex);
                const index2 = index1 + 1;
                const fraction = inputIndex - index1;
                const sample1 = inputData[index1] || 0;
                const sample2 = index2 < inputData.length ? inputData[index2] : 0;
                outputData[i] = sample1 + (sample2 - sample1) * fraction; // Linear interpolation
            }
            return outputData;
        }

        function startAudioCapture() {
            if (!microphonePermission || !mediaStream) {
                addMessage('‚ö†Ô∏è No microphone - sending PTT event only.');
                return;
            }

            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                const source = audioContext.createMediaStreamSource(mediaStream);
                // Use standard buffer size for good latency/performance balance
                const processor = audioContext.createScriptProcessor(2048, 1, 1);
                
                if (!webCodecsSupported || !webCodecsEncoder) {
                    addMessage('‚ùå Cannot start audio capture: WebCodecs Opus not available');
                    return;
                }
                
                addMessage(`üéµ Capturing at ${audioContext.sampleRate}Hz, encoding with WebCodecs Opus.`);
                
                processor.onaudioprocess = function(event) {
                    if (!isPTTActive || !webCodecsEncoder) return;

                    const inputData = event.inputBuffer.getChannelData(0);
                    
                    // Resample to 48kHz for Opus if needed
                    const resampledData = audioContext.sampleRate !== OPUS_SAMPLE_RATE ? 
                        resample(inputData, audioContext.sampleRate, OPUS_SAMPLE_RATE) : 
                        inputData;
                    
                    // Create AudioData for WebCodecs with proper timestamp
                    const audioData = new AudioData({
                        format: 'f32-planar',
                        sampleRate: OPUS_SAMPLE_RATE,
                        numberOfFrames: resampledData.length,
                        numberOfChannels: 1,
                        timestamp: audioTimestamp,
                        data: resampledData
                    });
                    
                    // Update timestamp for next frame (microseconds)
                    audioTimestamp += (resampledData.length * 1000000) / OPUS_SAMPLE_RATE;
                    
                    webCodecsEncoder.encode(audioData);
                    audioData.close(); // Important: release memory
                };
                
                source.connect(processor);
                // Mute the processor output to prevent feedback
                const muteGain = audioContext.createGain();
                muteGain.gain.value = 0;
                processor.connect(muteGain);
                muteGain.connect(audioContext.destination);
                
                window.audioSource = source;
                window.audioProcessor = processor;
                
                addMessage('üé§ Opus audio capture started.');
                
            } catch (error) {
                addMessage('‚ùå Audio capture failed: ' + error.message);
            }
        }

        function stopAudioCapture() {
            if (window.audioProcessor) {
                window.audioProcessor.disconnect();
                window.audioProcessor.onaudioprocess = null;
            }
            if (window.audioSource) {
                window.audioSource.disconnect();
            }
            window.audioProcessor = null;
            window.audioSource = null;
            nextPlayTime = 0;
            
            addMessage('üé§ Opus audio capture stopped.');
        }

        function sendOpusAudioChunk(encodedChunk) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const byteLength = encodedChunk.byteLength;
                const audioEvent = {
                    type: 'audio_data',
                    timestamp: new Date().toISOString(),
                    data: {
                        chunk_size: byteLength,
                        format: 'opus',
                        sample_rate: OPUS_SAMPLE_RATE,
                        channels: 1
                    }
                };
                
                ws.send(JSON.stringify(audioEvent));
                
                // Create array buffer from encoded chunk
                const buffer = new ArrayBuffer(encodedChunk.byteLength);
                encodedChunk.copyTo(new Uint8Array(buffer));
                ws.send(buffer);
                
                // Update transmission stats
                audioStats.transmittedBytes += byteLength;
                
                if (Math.random() < 0.05) { // Only log 5% of chunks
                    addMessage('üì§ Sent Opus chunk: ' + byteLength + ' bytes');
                }
            } else {
                addMessage('‚ùå WebSocket not ready for audio transmission');
            }
        }
        
        
        function initializeAudioMixer() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (!audioMixerGain) {
                audioMixerGain = audioContext.createGain();
                audioMixerGain.gain.value = 0.8; // Set overall volume to prevent clipping
                audioMixerGain.connect(audioContext.destination);
                addMessage('üéöÔ∏è Audio mixer initialized');
            }
        }

        function addToAudioBuffer(pcmData, sampleRate, userID) {
            // Add audio chunk to buffer
            audioBuffer.push({
                data: pcmData,
                sampleRate: sampleRate,
                userID: userID,
                timestamp: performance.now()
            });

            // Limit buffer size to prevent memory buildup
            if (audioBuffer.length > BUFFER_MAX_SIZE) {
                audioBuffer.shift(); // Remove oldest chunk
                addMessage('‚ö†Ô∏è Audio buffer overflow, dropping old chunks');
            }

            // Start playback when we have enough buffered
            if (!isPlayingBuffer && audioBuffer.length >= BUFFER_TARGET_SIZE) {
                startBufferedPlayback();
            }
        }

        async function startBufferedPlayback() {
            if (isPlayingBuffer) return;
            isPlayingBuffer = true;
            addMessage('üéµ Starting buffered audio playback with ~100ms delay');

            while (audioBuffer.length > 0) {
                const chunk = audioBuffer.shift();
                
                try {
                    await playAudioWithMixingBuffered(chunk.data, chunk.sampleRate, chunk.userID);
                    
                    // Wait a bit between chunks for smoother playback
                    await new Promise(resolve => setTimeout(resolve, 15));
                    
                } catch (error) {
                    addMessage(`‚ö†Ô∏è Buffer playback error: ${error.message}`);
                }
                
                // If buffer gets too low, pause until it fills up again
                if (audioBuffer.length < 2) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
            }
            
            isPlayingBuffer = false;
            addMessage('üîá Buffered audio playback stopped');
        }

        async function playDecodedAudio(audioData) {
            try {
                const numberOfFrames = audioData.numberOfFrames;
                const numberOfChannels = audioData.numberOfChannels;
                const sampleRate = audioData.sampleRate;
                
                // Use more efficient buffer allocation
                const bufferSize = numberOfFrames * numberOfChannels;
                const pcmBuffer = new ArrayBuffer(bufferSize * 4); // 4 bytes per float32
                const pcmData = new Float32Array(pcmBuffer);
                
                // Copy all audio data efficiently
                audioData.copyTo(pcmBuffer, { planeIndex: 0, format: 'f32-planar' });
                
                // Extract first channel if multi-channel
                let monoData = pcmData;
                if (numberOfChannels > 1) {
                    monoData = new Float32Array(numberOfFrames);
                    for (let i = 0; i < numberOfFrames; i++) {
                        monoData[i] = pcmData[i * numberOfChannels]; // Take first channel
                    }
                }
                
                // Play directly for low latency
                await playAudioWithMixing(monoData, sampleRate, 'opus-user');
                
                // Important: close AudioData to free memory
                audioData.close();
                
            } catch (error) {
                addMessage(`‚ùå Error playing decoded audio: ${error.message}`);
                if (audioData) {
                    audioData.close(); // Ensure cleanup even on error
                }
            }
        }

        async function playAudioWithMixingBuffered(pcmData, sampleRate, userID) {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                if (!audioMixerGain) {
                    initializeAudioMixer();
                }

                if (!pcmData || pcmData.length === 0) return;

                // Create audio buffer
                const audioBuffer = audioContext.createBuffer(1, pcmData.length, sampleRate);
                audioBuffer.getChannelData(0).set(pcmData);

                const userGain = audioContext.createGain();
                userGain.gain.value = 0.6; // Conservative volume for buffered playback

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(userGain);
                userGain.connect(audioMixerGain);

                // Play immediately without complex scheduling
                source.start();

                source.onended = () => {
                    userGain.disconnect();
                };

            } catch (error) {
                addMessage(`‚ö†Ô∏è Buffered audio playback failed for user ${userID}: ${error.message}`);
            }
        }

        async function playAudioWithMixing(pcmData, sampleRate, userID) {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                if (!audioMixerGain) {
                    initializeAudioMixer();
                }

                if (!pcmData || pcmData.length === 0) return;

                const audioBuffer = audioContext.createBuffer(1, pcmData.length, sampleRate);
                audioBuffer.getChannelData(0).set(pcmData);

                const userGain = audioContext.createGain();
                userGain.gain.value = 0.8;

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(userGain);
                userGain.connect(audioMixerGain);

                source.start();

                source.onended = () => {
                    userGain.disconnect();
                };

            } catch (error) {
                addMessage(`‚ö†Ô∏è Audio playback failed for user ${userID}: ${error.message}`);
            }
        }

        async function playReceivedAudio(audioData, userID = 'unknown', metadata) {
            try {
                if (!metadata) {
                    addMessage('‚ö†Ô∏è Received audio data without metadata. Cannot play.');
                    return;
                }

                let pcmData;
                const format = metadata.data.format;
                const sampleRate = metadata.data.sample_rate;
                
                // Update reception stats
                audioStats.receivedBytes += audioData.byteLength || audioData.length || 0;

                if (format !== 'opus') {
                    addMessage(`‚ö†Ô∏è Non-Opus audio format "${format}" from ${userID}. Only Opus is supported.`);
                    return;
                }
                
                if (!webCodecsSupported || !webCodecsDecoder) {
                    addMessage(`‚ö†Ô∏è WebCodecs Opus decoder not ready, skipping audio from ${userID}`);
                    return;
                }
                
                try {
                    // Create EncodedAudioChunk for WebCodecs decoder
                    const encodedChunk = new EncodedAudioChunk({
                        type: 'key', // Opus frames are typically self-contained
                        timestamp: 0, // Let decoder handle timing
                        data: audioData,
                        duration: null // Let decoder determine duration
                    });
                    
                    webCodecsDecoder.decode(encodedChunk);
                    // Note: decoded audio will be handled in the decoder's output callback
                } catch (err) {
                    addMessage(`‚ùå Failed to decode Opus from ${userID}: ${err.message}`);
                }

            } catch (error) {
                addMessage(`‚ùå Error processing received audio from ${userID}: ${error.message}`);
            }
        }

        // --- WebSocket and UI Functions ---

        function connect() {
            if (ws) return;
            
            ws = new WebSocket('ws://localhost:8080/ws');
            
            ws.onopen = function() {
                connectionStatus.classList.add('connected');
                connectionText.textContent = 'Connected';
                addMessage('Connected to server');
                updateStats();
            };
            
            ws.onmessage = function(event) {
                if (event.data instanceof ArrayBuffer) {
                    const userID = currentAudioMetadata ? currentAudioMetadata.user_id : 'unknown';
                    playReceivedAudio(event.data, userID, currentAudioMetadata);
                    currentAudioMetadata = null; // Clear after use
                    
                } else if (event.data instanceof Blob) {
                    const userID = currentAudioMetadata ? currentAudioMetadata.user_id : 'unknown';
                    const metadataForBlob = currentAudioMetadata;
                    currentAudioMetadata = null;
                    
                    event.data.arrayBuffer().then(buffer => {
                        playReceivedAudio(buffer, userID, metadataForBlob);
                    });
                    
                } else if (typeof event.data === 'string') {
                    try {
                        const data = JSON.parse(event.data);
                        
                        if (data.type === 'audio_data') {
                            currentAudioMetadata = data; // Store for the next binary frame
                            return;
                        }
                        
                        handleServerEvent(data);
                    } catch (e) {
                        addMessage('Received non-JSON text: ' + event.data);
                    }
                } else {
                    addMessage('Received unknown data type: ' + typeof event.data);
                }
            };
            
            ws.onclose = function() {
                connectionStatus.classList.remove('connected');
                connectionText.textContent = 'Disconnected';
                userInfo.textContent = '';
                addMessage('Disconnected from server. Reconnecting in 3s...');
                pttButton.disabled = true;
                ws = null;
                setTimeout(connect, 3000);
            };
            
            ws.onerror = function(error) {
                addMessage('Connection error: ' + JSON.stringify(error));
            };
        }

        function handleServerEvent(event) {
            addMessage(`Event: ${event.type} from ${event.user_id ? event.user_id.substring(0,8) : 'server'} ${event.data ? '- ' + JSON.stringify(event.data) : ''}`);
            
            switch (event.type) {
                case 'user_join':
                    if (event.user_id && event.data && event.data.username) {
                        if (!currentUser) { // Assume first join event is for us
                            if (event.user_id) {
                                currentUser = {
                                    id: event.user_id,
                                    username: event.data.username
                                };
                                userInfo.textContent = ` - ${event.data.username}`;
                            }
                        }
                    }
                    updateStats();
                    updateUsersList();
                    break;
                    
                case 'user_leave':
                    updateStats();
                    updateUsersList();
                    break;
                    
                case 'channel_join':
                    if (event.user_id === (currentUser ? currentUser.id : '')) {
                        currentChannel = event.channel_id;
                        document.getElementById('channel-input').value = currentChannel;
                    }
                    updatePTTButtonState();
                    updateStats();
                    updateChannelsList();
                    updateUsersList();
                    break;
                    
                case 'channel_leave':
                    if (event.user_id === (currentUser ? currentUser.id : '')) {
                        currentChannel = '';
                        document.getElementById('channel-input').value = '';
                    }
                    updatePTTButtonState();
                    updateStats();
                    updateChannelsList();
                    updateUsersList();
                    break;
                    
                case 'ptt_start':
                    addMessage(`üéôÔ∏è ${event.data.username} started talking in ${event.channel_id}`);
                    highlightTalkingUser(event.user_id, true);
                    // Start reception stats if someone else is talking
                    if (event.user_id !== (currentUser ? currentUser.id : '')) {
                        startReceptionStats();
                    }
                    break;
                    
                case 'ptt_end':
                    addMessage(`üîá ${event.data.username} stopped talking in ${event.channel_id}`);
                    highlightTalkingUser(event.user_id, false);
                    // Stop reception stats if someone else stopped talking
                    if (event.user_id !== (currentUser ? currentUser.id : '')) {
                        stopReceptionStats();
                    }
                    break;
                    
                case 'heartbeat':
                    // Silent heartbeat response
                    break;
            }
        }

        function updatePTTButtonState() {
            if (!webCodecsSupported) {
                pttButton.disabled = true;
                pttButton.textContent = 'WEBCODECS NOT SUPPORTED';
            } else if (!microphonePermission) {
                pttButton.disabled = true;
                pttButton.textContent = 'GRANT MIC PERMISSION';
            } else if (!currentChannel) {
                pttButton.disabled = true;
                pttButton.textContent = 'JOIN A CHANNEL TO TALK';
            } else if (microphonePermission && currentChannel && ws && ws.readyState === WebSocket.OPEN) {
                pttButton.disabled = false;
                pttButton.textContent = 'HOLD TO TALK (OPUS)';
            } else {
                pttButton.disabled = true;
                pttButton.textContent = 'CONNECTING...';
            }
        }

        function sendEvent(eventType, data = {}) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const event = {
                    type: eventType,
                    channel_id: currentChannel,
                    timestamp: new Date().toISOString(),
                    data: data
                };
                ws.send(JSON.stringify(event));
            }
        }

        function joinChannel() {
            const channelName = document.getElementById('channel-input').value.trim();
            if (!channelName) { 
                alert('Please enter a channel name');
                return;
            }
            
            sendEvent('channel_join', { channel_name: channelName });
        }

        function leaveChannel() {
            if (currentChannel) {
                sendEvent('channel_leave');
            }
        }

        function startPTT() {
            if (pttButton.disabled || isPTTActive) return;
            
            isPTTActive = true;
            pttButton.classList.add('active');
            
            // Start transmission stats tracking
            startTransmissionStats();
            
            if (microphonePermission) {
                pttButton.textContent = 'TRANSMITTING...';
                startAudioCapture();
            } else {
                pttButton.textContent = 'TRANSMITTING EVENT...';
            }
            
            sendEvent('ptt_start');
        }

        function endPTT() {
            if (!isPTTActive) return;
            
            isPTTActive = false;
            pttButton.classList.remove('active');
            
            // Stop transmission stats tracking
            stopTransmissionStats();
            
            if (microphonePermission) {
                stopAudioCapture();
            }
            
            updatePTTButtonState();
            sendEvent('ptt_end');
        }

        function updateStats() {
            fetch('/api/stats')
                .then(response => response.json())
                .then(stats => {
                    document.getElementById('active-channels').textContent = stats.active_channels;
                    document.getElementById('connected-users').textContent = stats.active_users;
                    document.getElementById('total-clients').textContent = stats.connected_clients;
                })
                .catch(err => console.error('Failed to fetch stats:', err));
        }

        function updateChannelsList() {
            fetch('/api/channels')
                .then(response => response.json())
                .then(data => {
                    const channelsList = document.getElementById('channels-list');
                    if (data.channels && data.channels.length > 0) {
                        channelsList.innerHTML = data.channels.map(channel => 
                            `<div class="channel-item ${channel.id === currentChannel ? 'active' : ''}" onclick="selectChannel('${channel.id}')">
                                ${channel.name} (${channel.users.length} users)
                            </div>`
                        ).join('');
                    } else {
                        channelsList.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">No active channels</div>';
                    }
                })
                .catch(err => console.error('Failed to fetch channels:', err));
        }

        function updateUsersList() {
            fetch('/api/users')
                .then(response => response.json())
                .then(data => {
                    const usersList = document.getElementById('users-list');
                    if (data.users && data.users.length > 0) {
                        usersList.innerHTML = data.users.map(user => 
                            `<div class="user-item ${user.is_active ? 'active' : ''}" id="user-${user.id}">
                                ${user.username}${user.channel ? ` (${user.channel})` : ''}
                            </div>`
                        ).join('');
                    } else {
                        usersList.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">No connected users</div>';
                    }
                })
                .catch(err => console.error('Failed to fetch users:', err));
        }

        function selectChannel(channelId) {
            document.getElementById('channel-input').value = channelId;
            joinChannel();
        }

        function highlightTalkingUser(userId, isTalking) {
            const userElement = document.getElementById(`user-${userId}`);
            if (userElement) {
                if (isTalking) {
                    userElement.classList.add('talking');
                } else {
                    userElement.classList.remove('talking');
                }
            }
        }

        function addMessage(message) {
            const div = document.createElement('div');
            div.textContent = new Date().toLocaleTimeString() + ' - ' + message;
            messagesDiv.appendChild(div);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.code === 'Space' && !e.repeat && !pttButton.disabled) {
                e.preventDefault();
                pttButton.dispatchEvent(new MouseEvent('mousedown'));
            }
        });

        document.addEventListener('keyup', function(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                pttButton.dispatchEvent(new MouseEvent('mouseup'));
            }
        });

        window.addEventListener('keydown', function(e) {
            if(e.keyCode === 32 && e.target === document.body) {
                e.preventDefault();
            }
        });

        window.onload = function() {
            connect();
            initializeAudio();
            updateOpusStatus(); // Initialize Opus status display
            setInterval(updateStats, 2000);
            setInterval(updateChannelsList, 3000);
            setInterval(updateUsersList, 3000);
        };
    </script>
</body>
</html>
